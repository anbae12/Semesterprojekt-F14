\section{Mikrocontroller}
\label{sec:mikrocontroller}
%
\subsection{Krav til mikrocontrolleren}
Mikrocontrolleren har følgende opgaver: 

\begin{itemize}
\itemsep1pt
	\item Afvikling af regulatorerne.
	\item Kommunikation med FPGA vha. SPI.
	\item Modtage kommandoer fra brugeren via UART.
	\item Sende relevant data til brugeren via UART.
\end{itemize}

Regulatorerne skal afvikles i hård realtid\footnote{Dvs. at task'en skal afvikles, inden dens deadline - inden for en samplingperiode \citep{operating_systems_concepts_ed8}.},
da de er designet under antagelsen om periodisk afvikling.

SPI\footnote{Serial Peripheral Interface, også kaldet SSI.} bruges til at overføre PTS's position fra FPGA til mikrocontroller.
Desuden overføres beregnet duty cycle fra mikrocontroller til FPGA.
Kommunikationen skal være tilpas hurtig, så regulatorerne ikke regner på forældet data.
Forsinkelsen for overførsel af data for begge motorer vurderes til ikke at måtte overstige 5\% af samplingperioden.
Ved $T_s = \frac{1}{600}$ er det: 
\begin{equation}
	T_{\text{SPI delay}} = \frac{1}{600} \cdot 5\% = 83,3~[\micro s]
	\label{eq:uc:spi-krav}
\end{equation}

Systemet skal kunne modtage brugerinput gennem et terminalprogram.
Brugerinterfacet er ikke tidskritisk.
Der skal være mulighed for at udlæse væsentlige systemparametre såsom:
PTS's position, ønsket position, aktuel PWM-duty cycle osv.

%\begin{itemize}
%\itemsep1pt
%	\item PTS' position. 
%	\item Ønsket position. 
%	\item Afvigelse fra ønsket position. 
%\end{itemize}
Desuden skal systemet gemme disse informationer i en logfil,
som udskrives løbende.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beskrivelse af mikrocontroller}
Den udleverede mikrocontroller er en 32-bits Stellaris LM3S6965, 
baseret på en ARM Cortex M3-kerne. 
Den opererer ved 50 [MHz] og bruger Thump 2 instruktionssættet. 
Den indeholder 256 [kB] flash hukommelse samt 64 [kB] SRAM \citep{lm3s6965}.

SPI er indbygget som et hardwaremodul, 
med seperate FIFO-buffere til afsendelse og modtagelse. 
Hardwaren sender data fra den ene FIFO-buffer og 
lægger modtaget data i den anden. 
Derfor er det ikke nødvendigt for programmøren at holde styr på timingen. 
Størrelsen af hvert dataframe kan være 4 - 16 bits. 

UART er også implementeret som et hardwaremodul. 
Modulet indeholder seperate FIFO-buffere til afsendelse og modtagelse af data, hver med plads til 16 datawords à 8 bit. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Valg af operativsystem og schedulering}
Det er valgt at bruge FreeRTOS, da dette styresystem gør brug af tvungen schedulering med prioritering (preemptive priority), hvilket sikrer hård realtid.
Desuden har gruppen erfaring med styresystemet.

%Der er undersøgt fire forskellige muligheder for schedulering.
%CooCox CoOS\footnote{\citep{www.coocox.com/CoOS.htm}} og FreeRTOS\footnote{\citep{freertos.org}}
%er komplette realtids-operativsystemer. 
%Run-To-Complete-Scheduler (RTCS) er en simpel scheduler med frivillig (non-preemtive) schedulering.
%Ved Super loop metoden afvikles al koden i main-loopet vha. ticks.
%De fire scheduleringsmuligheder er beskrevet i tabel \ref{tb:os_comparison}.

%Til valget er der lagt vægt på om scheduleringen opfylder kravet til realtidsafvikling af regulatorerne.
%\begin{figure}[th!]
%\centering

%\begin{tabu}{l|[1.25pt]l|l|l|l}
% & CoOS & FreeRTOS & RTCS & Super loop \\ \tabucline[1.25pt]{-}
%Schedulering & Preemptive priority  & Preemptive priority  & Non- & Non-  \\ 
%Køer & Ja & Ja & Nej & Nej \\ \hline 
%Semaforer & Tællende og Binære  & Tællende og Binære & Binære  & Nej  \\
%\end{tabu}
%\captionsetup{type=table}
%\caption{Specifikationer for de undersøgte systemer.}
%\label{tb:os_comparison}
%\end{figure}

%De fire muligheder tilbyder alle den nødvendige funktionalitet til hård realtid. 
%FreeRTOS og CoOS giver begge mulighed for at tasks uden realtidskrav kan afbrydes midlertidigt.
%Dette gør at disse tasks er lettere at programmere, da der ikke behøves at tage højde for 
%Dette letter programmeringsarbejdet, da kun timingen af task med realtidskrav skal overholdes.

%
\subsection{Implementering}
%disp: 
% task diagram
% beskrivelse af tasks
% implementering af enkelt task (CONTROL TASK). 
%   - hvordan sikres at denne kører realtid.
% 
% beskrivelse af interfacet
% 
%\todo[inline, author=Michael]{Venter på at kodens struktur er helt færdig - inden da giver det ikke mening at skrive dette afsnit færdigt. }
Systemet er opdelt i separate tasks.
Taskdiagrammet er vist på figur \ref{fig:task_diagram}. 

% TASK DIAGRAM
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance = 3.2cm]
	\include*{./graphics/uc_task_diagram}
\end{tikzpicture}
\caption[Taskdiagram]{Taskdiagrammet viser programmets opdeling i tasks.}
\label{fig:task_diagram}
\end{figure}

\subsubsection{Beskrivelse af de enkelte tasks}
	\textbf{UART send og -receive}\\ 
	Da UART hardwarebufferen kun indeholder 16 pladser \citep[Side. 430]{lm3s6965},
	sørger en Send og en Recieve task for at sende data videre til og fra resten af programmet.
	De to ekstra semaforer som Interface tilgår er til at reservere de to buffere så indtastede og
	printede tekststrenge ikke kan afbrydes (kun én task kan skrive til eller læse fra UART ad gangen).\\
	\textbf{Control}\\ 
	Denne task afvikler regulatorerne. Se mere indgående beskrivelse i sektion \ref{sec:control_task}.
	Denne task afvikles med højeste prioritet, hvilket sikrer realtid med en frekvens på 600 [Hz]. 
	Denne task sørger for at SPI-kommunikationen med FPGA'en bliver afviklet på de rigtige tidspunkter.\\
	\textbf{Logger}\\ 
	Denne task opdaterer logfilen med data fra statuskøen.\\
	\textbf{Interface}\\ 
	Denne task tolker på brugerinputs og sender relevante kommandoer til Control task'en.

\subsubsection{Control task}
\label{sec:control_task}
Control task'en henter en koordinat, transformerer koordinaten,
udregner en PWM-duty cycle for hver regulator og opdaterer loggen.
Hver gang control task'en bliver kørt bliver der hentet to positioner
ind via SPI mens de to nye PWM-duty cycles sendes.
Ved tracking skriver Control task'en positioner og PWM-duty cycles i loggen,

% \subsubsection{Interface task}
% \label{sec:interface}
% Brugerinterfacet gør det overskueligt at styre og skifte mellem de forskellige tilstande som systemet kan køres i.
% Der er lavet funktioner som bruges til test af specifikke funktioner (fx at sætte en bestemt PWM duty cycle)
% og funktioner som starter en større test (fx tracking af lerdueparablen).
% Formålet er at simplificere arbjedet med udviklingen og justeringen af regulatoren -
% det er altså ikke tænkt til en kunde som ikke ved noget om systemet.
% De primære funktioner er at sætte en position eller starte tracking af lerduen.
% Hvis det indtastede ikke bliver genkendt bliver en liste over gyldige funktioner udskrevet.
% 
% \begin{figure}[th!]
% \centering
% \begin{tabu}{l|[1.25pt]l|l}
% Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
% start & Start tracking af lerdue &   \\\hline 
% stop & Stop systemet &   \\\hline 
% open & Start åben sløjfe test &  \\\hline  
% reset & Gå til udgangsposition &   \\\hline 
% C fxx.fyy.fzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter, \\         
%             & &  f = fortegn ($+$ ell. $-$)\\\hline 
% A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
% Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
% & & f = fortegn ($+$ ell. $-$),  \\
% & & xx = PWM dutycycle i \%
% \end{tabu} 

%\begin{tabu}{|l|[1.25pt]l|l|}\hline
%Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
%read & Slå log til eller fra.  &   \\\hline 
%start & Start tracking af lerdue &   \\\hline 
%stop & Stop systemet &   \\\hline 
%open & Start åben sløjfe test &  \\\hline  
%reset & Gå til udgangsposition &   \\\hline 
%C xxx.yyy.zzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter \\\hline 
%A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
%Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
%& & f = fortegn ($+$ ell. $-$),  \\
%& & xx = PWM dutycycle i \%\\\hline
%\end{tabu} 
% \captionsetup{type=table}
% \caption{Brugerinterfacets kommandoer.}
% \label{tb:uart_interface}
% \end{figure}

\subsubsection{SPI}
\label{sec:spi-implementering}
Mikrocontrolleren agerer master, da den står for systemets timing. FPGA'en er derfor programmeret som SPI slave.

Mikrocontrollerens SPI-modul har indbygget tre forskellige standarder: TI Synchronous Serial Frame Format (SSFT), Freescale og Microwire. 
%Til at overfører data mellem Mikrocontrolleren og FPGA’en skal der bruges en enkel protokol med full duplex. \todo[author=Anders]{Hovedgrundene til valget af SPI protokol.}
%Hovedgrundene for at protokollen skal være enkel, er at der ikke sendes meget data, dataene er enkel, og afstanden, den sendes, er kort. 
%Microwire er ikke full duplex. Så det er enten SSFt eller Freescale, der skulle bruges. Da SSFT havde færre opsætningsmuligheder, blev den valgt som protokol. 
%I SSFT ligger svaret på nogle af overvejelserne. Overvejelserne har været om MOSI skal trigger på rising eller falling edge, og hvordan Slave Select skulle opføre sig.
Microwire blev udelukket da den ikke er full-duplex og dermed ikke en SPI standard. 
Freescale formatet blev udelukket da opsætningen af denne vurderedes mere kompliceret end for SSFT,
uden at tilføje ekstra muligheder.
Valget faldt derfor på SSFT.

Størrelse af data framen blev valgt til 16 bit, hvilket giver mulighed for at sende
motorens PWM-duty cycle og deres position (begge 11 bit) samt kontroldata.
Opbygningen af de to datawords kan ses på figur \ref{fig:protokol1}.

\begin{figure}[h!]
\centering
\subfloat[Kommando fra mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPImasterslave}
\end{tikzpicture}
}
\qquad
\subfloat[Svar fra FPGA til mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
\label{fig:spi_from_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPIslavemaster}
\end{tikzpicture}
}
\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
\label{fig:protokol1}
\end{figure}
%\todo[inline, author=Michael]{flot figur, i like :)}

%\begin{figure}[h!]
%\centering
%\subfloat[Mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
%\begin{tabular}{|p{4cm}|}   \hline
 %   Motor (1 bit) \\   \hline
 %   Retning (1 bit) \\   \hline
%    Ignore PWM (1 bit) \\    \hline
%    N/A (2 bit) \\
 %    \\\hline
 %    \\ \\ \\ \\
 %   PWM duty cycle \\
 %   (11 bits) \\ \\ \\ \\ \\   \hline
%  \end{tabular}}
%\qquad
%\subfloat[FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
%\label{fig:spi_from_fpga}]{%
%\begin{tabular}{|p{4cm}|} \hline
  %  Motor (1 bit) \\    \hline \\
%    N/A (4 bit) \\
%     \\ \\    \hline
%     \\ \\ \\ \\
%    Position (ticks) \\
%    (11 bits) \\ \\ \\ \\ \\    \hline
%  \end{tabular}}
%\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
%\label{fig:protokol1}
%\end{figure}
Figur \ref{fig:spi_to_fpga} viser indholdet af datawords der bliver sendt fra mikrocontrolleren. 
Motorbit vælger aktuel motor, retningsbit vælger hvilken retning
denne skal dreje og PWM-duty cycle indeholder den ønskede PWM-duty cycle. 
Hvis setPWM-bit ikke er sat ignoreres den modtagne besked,
mens den aktuelle motorposition stadig returneres som vist på figur \ref{fig:spi_from_fpga}. 

%Da SPI er full duplex sendes data fra  Mikrocontrolleren og FPGA’en synkront - FPGA’en sender et dataword samtidig med mikrocontrolleren
 %Mikrocontrolleren sender den  PWM, der skal sættes på den bestemte motor i den bestemte retning. Det er det motor- og retningsbittene bestemmer.
%På Mikrocontrolleren ville man gerne kunne få en position uden, at den sætter en ny PWM. 
%Derfor skal der bruges en bit, hvor FGPA’en kan se om den skal sætte PWM’en, eller om den kun skal sende information tilbage. Der er det PWMset bruges til.
%På figur \ref{fig:spi_from_fpga} ses dataword'et som FPGA'en sender. FPGA'en sender positionen på den bestemte motor. 

\subsection{Test} 
Det testes hvorvidt SPI-overførslen og Control-task'en overholder timingkravene. 
Testen udføres ved at sætte en digital udgang høj mens task'en afvikles, og samtidig måle denne udgang med et oscilloskop. 
Appendix \ref{sec:uctestappendix} forklarer fremgangsmåden og diskuterer måleresultaterne. 

Det blev fundet at SPI-overførslen af 2 datawords blev udført 40,54 [\micro s], hvilket opfylder kravet på 83,3 [\micro s]. 
Control-task'en blev afviklet periodisk med en afvigelse på under 1\%. 

\subsection{Delkonklusion}
Det blev valgt at benytte den udleverede LM3S6965 mikrocontroller.
Denne understøtter SPI og UART som hardwaremoduler. 

Det blev valgt at bruge FreeRTOS til scheduleringen,
da tvungen schedulering med prioritet sikrer hård realtid. 

Programmet blev delt op i fem task's; UART send, UART receive, Interface, Logger og Control. 
% Al realtidsfunktionalitet blev implementeret i Control-task'en. 

Det var påkrævet at Control-task'en kunne afvikles med en frekvens på 600 [Hz]. 
Task'ens afviklingstid blev målt til max. 360 [\(\micro\)s], hvilket var væsentlig lavere end den max. tilladte tid på \(\frac{1}{600}\) [s]. 
SPI-kommunikationen kunne afvikles på 40,54 [\(\micro\)s], hvilket opfyldte kravet på max. 5\% af Control-task'ens periodetid. 

%Reguleringssløjferne kan ramme inden for kravene i kravspecifikationen.
