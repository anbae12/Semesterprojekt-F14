\section{Mikrocontroller}
\label{sec:mikrocontroller}
%
\subsection{Krav til mikrocontrolleren}
\todo[inline, author=Michael]{Husk at TEST sektionen skal se om vi opfylder disse krav. Hvis ikke vi tester tingene skal de slettes fra dette afsnit!!!}
Mikrocontrolleren har følgende opgaver: 
%\todo[inline, author=Michael]{YOU CANT TOUCH THIS - lad mig lige skrive færdig!}
%\todo[inline, author=Michael]{Denne sektion mangler generelt at blive forkortet. }
%\todo[inline, author=Michael]{Anders, kan vi ændre layouttet så listerne ikke tager så meget plads? }

\begin{itemize}
\itemsep1pt
	\item Afvikling af regulatorerne.
	\item Kommunikation med FPGA vha. SPI.
	\item Modtage kommandoer fra PC'en via UART.
	\item Sende relevant data til brugeren via UART.
\end{itemize}

Regulatorerne skal afvikles i hård realtid\footnote{Dvs. at task'en skal afvikles, inden dens deadline - inden for en samplingperiode.},
da det ellers er vanskelligt at modellere de digitale regulatorer matematisk.

SPI\footnote{Serial Peripheral Interface, også kaldet SSI} bruges til at overføre PTS's position fra FPGA til mikrocontroller.
Desuden overføres beregnet duty cycle fra mikrocontroller til FPGA.
Kommunikationen skal være tilpas hurtig, så regulatorerne ikke regner på forældet data.
Forsinkelsen for overførsel af data for begge motorer vurderes til ikke at måtte overstige 5\% af samplingperioden.
Ved $T_s = \frac{1}{600}$ er det: 
\begin{equation}
	T_{spi delay} = \frac{1}{600} \cdot 5 \% = 8,33 \cdot 10^{-5}[s]
	\label{eq:uc:spi-krav}
\end{equation}

Systemet skal kunne modtage brugerinput gennem et terminalprogram.
Brugerinterfacet er ikke tidskritisk.
Der skal være mulighed for at udlæse væsentlige systemparametre såsom:
PTS' position, ønsket position, aktuel PWM duty cycle osv.
\todo[inline, author=Michael]{Måske skal disse systemparametre defineres mere fast.}
%\begin{itemize}
%\itemsep1pt
%	\item PTS' position. 
%	\item Ønsket position. 
%	\item Afvigelse fra ønsket position. 
%\end{itemize}
Desuden skal systemet gemme disse informationer i en log-fil,
som kan udlæses efter systemet er færdig med at tracke målet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beskrivelse af mikrocontroller.}
Den udleverede mikrocontroller er en 32 bit Stellaris LM3S6965, baseret på en ARM Cortex M3 kerne. Den opererer ved 50 [MHz] og bruger Thump 2 instruktionssættet. Den indeholder 256 [kB] flash hukommelse samt 64 [kB] SRAM \citep{lm3s6965}.

SPI er indbygget som et hardwaremodul, med seperate FIFO buffere til afsendelse og modtagelse. Hardwaren sender data fra den ene den buffer og lægger modtaget data i den anden. Derfor er det ikke nødvendigt for programmøren at holde styr på timingen. Størrelsen af hvert dataframe kan være 4 - 16 bits. 

UART er også implementeret som et hardwaremodul. Modulet indeholder seperate FIFO buffere til afsendelse og modtagelse af data, hver med plads til 16 datawords (på max. 8 bit). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Valg af skedulering/operativsystem}
Der er undersøgt fire forskellige muligheder for skedulering.
CooCox CoOS\footnote{\citep{www.coocox.com/CoOS.htm}} og FreeRTOS\footnote{\citep{freertos.org}}
er komplette realtids-operativsystemer. 
Run-To-Complete-Scheduler (RTCS) er en simpel scheduler introduceret i semesterets programmeringskursus.
Ved Super loop metoden afvikles al koden i main-loopet vha. ticks.
De fire skeduleringer er beskrevet i tabel \ref{tb:os_comparison}.
%\begin{itemize}
%\itemsep-2pt
%	\item Opfylder kravene til realtidsafvikling af regulatorerne. 
%	\item Muligheden for at (gen)bruge elementer fra EMP-kurset.
%\end{itemize}

Til valget er der lagt vægt på om skeduleringen opfylder kravet til realtidsafvikling af regulatorerne, samt muligheden for at genanvende elementer fra EMP-kurset.
\begin{figure}[th!]
\centering
\begin{tabu}{l|[2pt]l|l|l|l}
 & CoOS & FreeRTOS & RTCS & Super loop \\ \tabucline[2pt]{-}
Skedulering & Preemptive priority  & Preemptive priority  & Non-preemptive & Non-preemptive  \\ 
	           & /round robin		& /round robin              & &	\\\hline 
Køer & Ja & Ja & Nej & Nej \\ \hline 
Semaforer & Tællende og Binære  & Tællende og Binære & Binære  & Nej  \\\hline 
Introduceret & Nej & Ja & Ja & Ja \\ 
i programmeringskurset &   &   &   &   \\
\end{tabu}
%\begin{tabu}{|l|[2pt]l|l|l|l|}\hline
% & coOS & freeRTOS & RTCS & Super loop \\ \tabucline[2pt]{-}
%Skedulering & Preemptive priority  & Preemptive priority  & Non-preemptive & Non-preemptive  \\ 
%	           & /round robin		& /round robin              & &	\\\hline 
%Queues & Ja & Ja & Nej & Nej \\ \hline 
%Semaphore & Counting og Binære  & Counting og Binære & Binære  & Nej  \\\hline 
%Introduceret & Nej & Ja & Ja & Ja \\ 
%i EMP kurset &   &   &   &   \\\hline
%\end{tabu}
\captionsetup{type=table}
\caption{Specifikationer for de undersøgte systemer}
\label{tb:os_comparison}
\end{figure}
Med kravet om hård realtid og for at lette programmeringsarbejdet valgtes det at
benytte FreeRTOS, fordi det tilbyder tvungen skedulering (preemptive priority), hvor det er muligt
at prioritere regulerings-task'en højere end resten af programmet. Desuden lettes programmeringsarbejdet
fordi gruppen er bekendt med operativsystemet fra programmeringskurset.

%
\subsection{Implementering}
%disp: 
% task diagram
% beskrivelse af tasks
% implementering af enkelt task (CONTROL TASK). 
%   - hvordan sikres at denne kører realtid.
% 
% beskrivelse af interfacet
% 
\todo[inline, author=Michael]{Venter på at kodens struktur er helt færdig - inden da giver det ikke mening at skrive dette afsnit færdigt. }

Systemet er opdelt i separate tasks.
Taskdiagrammet er vist på figur \ref{fig:task_diagram}. 

% TASK DIAGRAM
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance = 3.2cm]
	\include*{./graphics/uc_task_diagram}
\end{tikzpicture}
\caption[Taskdiagram]{Taskdiagrammet viser programmets opdeling i tasks.}
\label{fig:task_diagram}
\end{figure}

\subsubsection{Beskrivelse af de enkelte tasks}
\begin{description}
\itemsep-3pt
	\item[UART send og -receive] Fordi UART hw.-bufferen kun indeholder 16 pladser \citep[Side. 430]{lm3s6965}
	sørger en Send og en Recieve task for at sende data videre til og fra resten af programmet.
	De to ekstra semaforer, som Interface tilgår er til at reservere de to buffers så indtastede og
	printede tekststrenge ikke kan afbrydes (kun én task kan skrive til eller læse fra UART ad gangen).
	\item[Control] Afvikler regulatorerne. Se mere indgående beskrivelse i sektion \ref{sec:control_task}.
	Denne task afvikles i realtid, med en frekvens på 600 [Hz]. 
	Denne task sørger for at SPI Kommunikationen med FPGA'en bliver afviklet på de rigtige tidspunkter.
	\item[Logger] Denne task opdaterer logfilen med data fra "status" køen.
	\item[Interface] Tolker på brugerinputs og sender relevante kommandoer til Control tasken.
\end{description}


\subsubsection{Control task}
\label{sec:control_task}
Control task'en henter et koordinat, transformerer koordinatet, udregner en PWM for hver regulator og opdaterer loggen.
Hver gang control task'en bliver kørt bliver der hentet to positioner ind via SPI mens de to nye PWM duty cycles sendes.
Control tasken ved hvilke ting der er relevant at gemme i loggen,
så ved start af tracking bliver positioner og PWM duty cycles gemt i loggen.
I kodeudsnittet \ref{ctrl_task} ses task'en som den bliver kørt hvis den er i tracking stadiet.

\lstinputlisting[language=c, 
        firstnumber=120,
        firstline=120, 
        lastline=122,
        ]{codeexample/ctrl_task.c}
\(\vdots\)
\lstinputlisting[language=c, 
        firstnumber=155,
        firstline=155, 
        lastline=163,
        ]{codeexample/ctrl_task.c}
\(\vdots\)
\lstinputlisting[language=c, 
        firstnumber=180,
        firstline=180, 
        lastline=186,
        caption={ af ctrl\_task.c.\label{ctrl_task}}
        ]{codeexample/ctrl_task.c}

\subsubsection{Interface task}
\label{sec:interface}
Brugerinterfacet gør det overskueligt at styre og skifte mellem de forskellige tilstande som systemet kan køres i.
Der er lavet funktioner som bruges til test af specifikke funktioner (fx at sætte en bestemt PWM duty cycle)
og funktioner som starter en større test (fx tracking af lerdueparablen).
Formålet er at gøre det simpelt for gruppen at udvikle regulatoren -
det er altså ikke tænkt til en kunde som ikke ved noget om systemet.
%Fjernelse af implementerede funktioner for at gøre det simpelt har ikke været en prioritet. 
De primære funktioner er at sætte en position eller starte tracking af lerduen.
Hvis det indtastede ikke bliver genkendt bliver en liste over gyldige funktioner udskrevet.

\begin{figure}[th!]
\centering
\begin{tabu}{l|[2pt]l|l}
Kommando: & Funktion: & Parametre: \\\tabucline[2pt]{-}
read & Slå log til eller fra.  &   \\\hline 
start & Start tracking af lerdue &   \\\hline 
stop & Stop systemet &   \\\hline 
open & Start åben sløjfe test &  \\\hline  
reset & Gå til udgangsposition &   \\\hline 
C xxx.yyy.zzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter \\\hline 
A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
& & f = fortegn ($+$ ell. $-$),  \\
& & xx = PWM dutycycle i \%
\end{tabu} 

%\begin{tabu}{|l|[2pt]l|l|}\hline
%Kommando: & Funktion: & Parametre: \\\tabucline[2pt]{-}
%read & Slå log til eller fra.  &   \\\hline 
%start & Start tracking af lerdue &   \\\hline 
%stop & Stop systemet &   \\\hline 
%open & Start åben sløjfe test &  \\\hline  
%reset & Gå til udgangsposition &   \\\hline 
%C xxx.yyy.zzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter \\\hline 
%A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
%Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
%& & f = fortegn ($+$ ell. $-$),  \\
%& & xx = PWM dutycycle i \%\\\hline
%\end{tabu} 
\captionsetup{type=table}
\caption{Brugerinterfacets kommandoer.}
\label{tb:uart_interface}
\end{figure}

\subsubsection{SPI}
\label{sec:spi-implementering}
Det blev vedtaget at mikrocontrolleren var masteren og FPGA'en blev slaven, da FPGA'en helst skulle være så enkel som mulig.

Mikrocontrollerens SPI-modul har indbygget tre forskellige standarder: TI Synchronous Serial Frame Format (SSFT), Freescale og Microwire. 
%Til at overfører data mellem Mikrocontrolleren og FPGA’en skal der bruges en enkel protokol med full duplex. \todo[author=Anders]{Hovedgrundene til valget af SPI protokol.}
%Hovedgrundene for at protokollen skal være enkel, er at der ikke sendes meget data, dataene er enkel, og afstanden, den sendes, er kort. 
%Microwire er ikke full duplex. Så det er enten SSFt eller Freescale, der skulle bruges. Da SSFT havde færre opsætningsmuligheder, blev den valgt som protokol. 
%I SSFT ligger svaret på nogle af overvejelserne. Overvejelserne har været om MOSI skal trigger på rising eller falling edge, og hvordan Slave Select skulle opføre sig.
Microwire blev udelukket da den ikke er full-duplex og dermed ikke en SPI standard. 
Freescale formatet blev udelukket da opsætningen af denne vurderedes mere kompliceret end for SSFT,
uden at tilføje ekstra muligheder.
Valget faldt derfor på SSFT.

Størrelse af data framen blev valgt til 16 bit, hvilket giver mulighed for at sende
motorens hastighed og deres position (begge 11 bit) samt kontroldata.
Opbygningen af de to datawords kan ses på figur \ref{fig:protokol1}.

\begin{figure}[h!]
\centering
\subfloat[Kommando fra mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPImasterslave}
\end{tikzpicture}
}
\qquad
\subfloat[Svar fra FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
\label{fig:spi_from_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPIslavemaster}
\end{tikzpicture}
}
\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
\label{fig:protokol1}
\end{figure}
%\todo[inline, author=Michael]{flot figur, i like :)}

%\begin{figure}[h!]
%\centering
%\subfloat[Mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
%\begin{tabular}{|p{4cm}|}   \hline
 %   Motor (1 bit) \\   \hline
 %   Retning (1 bit) \\   \hline
%    Ignore PWM (1 bit) \\    \hline
%    N/A (2 bit) \\
 %    \\\hline
 %    \\ \\ \\ \\
 %   PWM duty cycle \\
 %   (11 bits) \\ \\ \\ \\ \\   \hline
%  \end{tabular}}
%\qquad
%\subfloat[FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
%\label{fig:spi_from_fpga}]{%
%\begin{tabular}{|p{4cm}|} \hline
  %  Motor (1 bit) \\    \hline \\
%    N/A (4 bit) \\
%     \\ \\    \hline
%     \\ \\ \\ \\
%    Position (ticks) \\
%    (11 bits) \\ \\ \\ \\ \\    \hline
%  \end{tabular}}
%\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
%\label{fig:protokol1}
%\end{figure}
Figur \ref{fig:spi_to_fpga} viser indholdet af datawords der bliver sendt fra Mikrocontrolleren. 
Motorbitten vælger aktuel motor, retningsbitten vælger hvilken retning
denne skal dreje og PWM duty cycle indeholder den ønskede PWM. 
Hvis "Ignore"-bitten er sat ignoreres den modtagne besked, mens den aktuelle motorposition stadig returneressom vist på fig.  \ref{fig:spi_from_fpga}. 
%Da SPI er full duplex sendes data fra  Mikrocontrolleren og FPGA’en synkront - FPGA’en sender et dataword samtidig med mikrocontrolleren
 %Mikrocontrolleren sender den  PWM, der skal sættes på den bestemte motor i den bestemte retning. Det er det motor- og retningsbittene bestemmer.
%På Mikrocontrolleren ville man gerne kunne få en position uden, at den sætter en ny PWM. 
%Derfor skal der bruges en bit, hvor FGPA’en kan se om den skal sætte PWM’en, eller om den kun skal sende information tilbage. Der er det PWMset bruges til.
%På figur \ref{fig:spi_from_fpga} ses dataword'et som FPGA'en sender. FPGA'en sender positionen på den bestemte motor. 

\subsection{Test} 
% Test af SPI overførsel
% Test af realtidsafvikling af reguleringssløjferne, 
% lever vi op til kravene?
%
%Deadband er testet ved at øge PWM med 6 [Hz] til en motor hvor der blev målt position med 600 [Hz].
%Ved at se hvornår der sker den første bevægelse er er målt at deadband målt til 141 for tilt og 221 for pan motoren.
%Dette er indsat i en langsom regulator som bliver brugt til at sætte en enkelt position. Her kan error signalet være %størst og der er ikke de samme tidskrav til systemet. 
%
%Den matematiske model er sammenlignet med plotdata fra open loop sløjfen på tilt systemet.
%Pan systemet kan ikke bevæge sig hele vejen rundt, så der er ikke foretaget en open loop test af denne motor.
%Testen består i at gå fra 0 til 2047 PWM i trin af 1. PWM bliver forøget med 60[Hz] og der bliver målt position med 600[Hz].
%Sammenligningen er plottet i appendix XXX og den største fejlmargen var XXX.
%
%
%Realtidsafviklingen af systemet er målt ved at sætte en pin på mikrocontroller boardet og måle resultatet med et oscilloscop.
%Afviklingen af en enkelt control loop i tracking stadiet er målt til XXX \(\micro\) sekunder
%Det kan også aflæses at der er en fast afstand på 1666.667 \(\micro\) sekunder fra start til start, så freeRTOS kan godt følge med til at skedulere med 600 [Hz].
%I appendix XXX kan der ses en måling hvor der både bliver målt længden af en task og SPI kommunikationen.
%
%
SPI blev testet ved at skifte en digital pin før og efter SPI-funktion blev kaldt. 
Funktionen blev testet XXX gange, og resultat kan ses i tabel \ref{tb:spi-tests}. 
\todo[inline, author=Michael]{Udfør forsøget igen, vi mangler et større datasæt..}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|}
\hline 
Max:  & Min: & Median: & Gennemsnit: \\ 
\hline 
41,12 [\micro s] & 40,16 \micro s & 40,56 \micro s & 40,59 \micro s \\ 
\hline 
\end{tabular} 
\label{tb:spi-tests}
\caption{Data fra tests af SPI.}
\end{table}

Med en maks. afviklingstid på 41,12 \micro s, overholder implementeringen kravet på afvikling indenfor 83,3 \micro s, som opstillet i ligning \ref{eq:uc:spi-krav}.

Samme fremgangsmåde blev brugt til at tjekke timingen for controltask'en, som indeholder reguleringssløjfen. 
Kravet til afviklingen var: Reguleringsløjfen kører med 600 [Hz], samt at tasken afvikles inden næste periode. 
Dvs. en maks afviklingstid på 1/600 [s], da kravet på 600 [Hz] ellers ikke kunne opfyldes. 
Intervallet mellem hver afvikling af blev målt for 240 afvikling, og resultaterne er vist i tabel \ref{tb:ctrl-task-timing-test}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline 
 & Max:  & Min: & Median: & Gennemsnit: \\ 
\hline 
Målt interval: & 1,674 [ms] & 1,657 [ms] & 1,667 [ms] & 1,667 [ms] \\ 
\hline 
Afvigelse: & 6,933 [\micro s] & 9,067 [\micro s] & 0,533 [\micro s] & 0,005 [\micro s] \\ 
\hline 
\end{tabular} 
\label{tb:ctrl-task-timing-test}
\caption{Interval mellem hver afvikling af ctrl-task.}
\end{table}

Den højeste afvigelse på 9 \micro s er lav nok til at kravene opfyldes.
\todo[inline, author=Michael]{Udfør test af ctrl-taskens afviklingstid.}
%
%Reguleringssløjferne er testet ved at plotte loggen og heri aflæse den maksimale fejl.
%Systemet blev altid sat i samme startposition ved funktionen "reset'' som pegede ind på 18 ticks for tilt og 163 ticks for pan.
%Dette er også det første koordinat i testen, hvilket sikrer at systemet skal lede mindst muligt efter første koordinat.
%Der er foretaget mange test af systemet under fintuning af PID konstanterne.
%for de færdige værdier er der plottet figur XXX i appendix XXX.
%
%\todo[inline, color = green, author = Nikolaj]{Vi har måledata, men vi skal have beregnet nogle bedre PID især til pan systemet før jeg kan henvise til noget.}
%

\subsection{Delkonklusion}
FreeRTOS er brugbar til tidskritiske operationer.
Reguleringsstasken kan afvikles med 600 [Hz]. 
%Reguleringssløjferne kan ramme inden for kravene i kravspecifikationen.
