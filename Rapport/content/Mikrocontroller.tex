\section{Mikrocontroller}
\label{sec:mikrocontroller}
%
\subsection{Krav til mikrocontrolleren}
Mikrocontrolleren har følgende opgaver: 

\begin{itemize}
\itemsep1pt
	\item Afvikling af regulatorerne.
	\item Kommunikation med FPGA vha. SPI.
	\item Modtage kommandoer fra brugeren via UART.
	\item Sende relevant data til brugeren via UART.
\end{itemize}

Regulatorerne skal afvikles i hård realtid\footnote{Dvs. at task'en skal afvikles, inden dens deadline - inden for en samplingperiode \citep{operating_systems_concepts_ed8}.},
da de er designet under antagelsen om periodisk afvikling.

SPI\footnote{Serial Peripheral Interface, også kaldet SSI.} bruges til at overføre PTS's position fra FPGA til mikrocontroller.
Desuden overføres beregnet duty cycle fra mikrocontroller til FPGA.
Kommunikationen skal være tilpas hurtig, så regulatorerne ikke regner på forældet data.
Forsinkelsen for overførsel af data for begge motorer vurderes til ikke at måtte overstige 5\% af samplingperioden.
Ved $T_s = \frac{1}{600}$ er det: 
\begin{equation}
	T_{\text{SPI delay}} = \frac{1}{600} \cdot 5\% = 83,3~[\micro s]
	\label{eq:uc:spi-krav}
\end{equation}

Systemet skal kunne modtage brugerinput gennem et terminalprogram.
Brugerinterfacet er ikke tidskritisk.
Der skal være mulighed for at udlæse væsentlige systemparametre såsom:
PTS's position, ønsket position, aktuel PWM-duty cycle osv.

%\begin{itemize}
%\itemsep1pt
%	\item PTS' position. 
%	\item Ønsket position. 
%	\item Afvigelse fra ønsket position. 
%\end{itemize}
Desuden skal systemet gemme disse informationer i en logfil,
som udskrives løbende.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beskrivelse af mikrocontroller}
Den udleverede mikrocontroller er en 32-bits Stellaris LM3S6965, 
baseret på en ARM Cortex M3-kerne. 
Den opererer ved 50 [MHz] og bruger Thump 2 instruktionssættet. 
Den indeholder 256 [kB] flash hukommelse samt 64 [kB] SRAM \citep{lm3s6965}.

SPI er indbygget som et hardwaremodul, 
med seperate FIFO-buffere til afsendelse og modtagelse. 
Hardwaren sender data fra den ene FIFO-buffer og 
lægger modtaget data i den anden. 
Derfor er det ikke nødvendigt for programmøren at holde styr på timingen. 
Størrelsen af hvert dataframe kan være 4 - 16 bits. 

UART er også implementeret som et hardwaremodul. 
Modulet indeholder seperate FIFO-buffere til afsendelse og modtagelse af data, hver med plads til 16 datawords à 8 bit. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Valg af operativsystem og schedulering}
Det er valgt at bruge FreeRTOS, da dette styresystem gør brug af tvungen schedulering med prioritering (preemptive priority), hvilket sikrer hård realtid.
Desuden har gruppen erfaring med styresystemet.

%Der er undersøgt fire forskellige muligheder for schedulering.
%CooCox CoOS\footnote{\citep{www.coocox.com/CoOS.htm}} og FreeRTOS\footnote{\citep{freertos.org}}
%er komplette realtids-operativsystemer. 
%Run-To-Complete-Scheduler (RTCS) er en simpel scheduler med frivillig (non-preemtive) schedulering.
%Ved Super loop metoden afvikles al koden i main-loopet vha. ticks.
%De fire scheduleringsmuligheder er beskrevet i tabel \ref{tb:os_comparison}.

%Til valget er der lagt vægt på om scheduleringen opfylder kravet til realtidsafvikling af regulatorerne.
%\begin{figure}[th!]
%\centering

%\begin{tabu}{l|[1.25pt]l|l|l|l}
% & CoOS & FreeRTOS & RTCS & Super loop \\ \tabucline[1.25pt]{-}
%Schedulering & Preemptive priority  & Preemptive priority  & Non- & Non-  \\ 
%Køer & Ja & Ja & Nej & Nej \\ \hline 
%Semaforer & Tællende og Binære  & Tællende og Binære & Binære  & Nej  \\
%\end{tabu}
%\captionsetup{type=table}
%\caption{Specifikationer for de undersøgte systemer.}
%\label{tb:os_comparison}
%\end{figure}

%De fire muligheder tilbyder alle den nødvendige funktionalitet til hård realtid. 
%FreeRTOS og CoOS giver begge mulighed for at tasks uden realtidskrav kan afbrydes midlertidigt.
%Dette gør at disse tasks er lettere at programmere, da der ikke behøves at tage højde for 
%Dette letter programmeringsarbejdet, da kun timingen af task med realtidskrav skal overholdes.

%
\subsection{Implementering}
%disp: 
% task diagram
% beskrivelse af tasks
% implementering af enkelt task (CONTROL TASK). 
%   - hvordan sikres at denne kører realtid.
% 
% beskrivelse af interfacet
% 
%\todo[inline, author=Michael]{Venter på at kodens struktur er helt færdig - inden da giver det ikke mening at skrive dette afsnit færdigt. }
Systemet er opdelt i separate tasks.
Taskdiagrammet er vist på figur \ref{fig:task_diagram}. 

% TASK DIAGRAM
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance = 3.2cm]
	\include*{./graphics/uc_task_diagram}
\end{tikzpicture}
\caption[Taskdiagram]{Taskdiagrammet viser programmets opdeling i tasks.}
\label{fig:task_diagram}
\end{figure}

\subsubsection{Beskrivelse af de enkelte tasks}
	\textbf{UART send og -receive}\\ 
	Da UART hardwarebufferen kun indeholder 16 pladser \citep[Side. 430]{lm3s6965},
	sørger en Send og en Recieve task for at sende data videre til og fra resten af programmet.
	De to ekstra semaforer som Interface tilgår er til at reservere de to buffere så indtastede og
	printede tekststrenge ikke kan afbrydes (kun én task kan skrive til eller læse fra UART ad gangen).\\
	\textbf{Control}\\ 
	Denne task afvikler regulatorerne. Se mere indgående beskrivelse i sektion \ref{sec:control_task}.
	Denne task afvikles med højeste prioritet, hvilket sikrer realtid med en frekvens på 600 [Hz]. 
	Denne task sørger for at SPI-kommunikationen med FPGA'en bliver afviklet på de rigtige tidspunkter.\\
	\textbf{Logger}\\ 
	Denne task opdaterer logfilen med data fra statuskøen.\\
	\textbf{Interface}\\ 
	Denne task tolker på brugerinputs og sender relevante kommandoer til Control task'en.

\subsubsection{Control task}
\label{sec:control_task}
Control task'en henter en koordinat, transformerer koordinaten,
udregner en PWM-duty cycle for hver regulator og opdaterer loggen.
Hver gang control task'en bliver kørt bliver der hentet to positioner
ind via SPI mens de to nye PWM-duty cycles sendes.
Ved tracking skriver Control task'en positioner og PWM-duty cycles i loggen,

% \subsubsection{Interface task}
% \label{sec:interface}
% Brugerinterfacet gør det overskueligt at styre og skifte mellem de forskellige tilstande som systemet kan køres i.
% Der er lavet funktioner som bruges til test af specifikke funktioner (fx at sætte en bestemt PWM duty cycle)
% og funktioner som starter en større test (fx tracking af lerdueparablen).
% Formålet er at simplificere arbjedet med udviklingen og justeringen af regulatoren -
% det er altså ikke tænkt til en kunde som ikke ved noget om systemet.
% De primære funktioner er at sætte en position eller starte tracking af lerduen.
% Hvis det indtastede ikke bliver genkendt bliver en liste over gyldige funktioner udskrevet.
% 
% \begin{figure}[th!]
% \centering
% \begin{tabu}{l|[1.25pt]l|l}
% Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
% start & Start tracking af lerdue &   \\\hline 
% stop & Stop systemet &   \\\hline 
% open & Start åben sløjfe test &  \\\hline  
% reset & Gå til udgangsposition &   \\\hline 
% C fxx.fyy.fzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter, \\         
%             & &  f = fortegn ($+$ ell. $-$)\\\hline 
% A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
% Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
% & & f = fortegn ($+$ ell. $-$),  \\
% & & xx = PWM dutycycle i \%
% \end{tabu} 

%\begin{tabu}{|l|[1.25pt]l|l|}\hline
%Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
%read & Slå log til eller fra.  &   \\\hline 
%start & Start tracking af lerdue &   \\\hline 
%stop & Stop systemet &   \\\hline 
%open & Start åben sløjfe test &  \\\hline  
%reset & Gå til udgangsposition &   \\\hline 
%C xxx.yyy.zzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter \\\hline 
%A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
%Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
%& & f = fortegn ($+$ ell. $-$),  \\
%& & xx = PWM dutycycle i \%\\\hline
%\end{tabu} 
% \captionsetup{type=table}
% \caption{Brugerinterfacets kommandoer.}
% \label{tb:uart_interface}
% \end{figure}

\subsubsection{SPI}
\label{sec:spi-implementering}
Mikrocontrolleren agerer master, da den står for systemets timing. FPGA'en er derfor programmeret som SPI slave.

Mikrocontrollerens SPI-modul har indbygget tre forskellige standarder: TI Synchronous Serial Frame Format (SSFT), Freescale og Microwire. 
%Til at overfører data mellem Mikrocontrolleren og FPGA’en skal der bruges en enkel protokol med full duplex. \todo[author=Anders]{Hovedgrundene til valget af SPI protokol.}
%Hovedgrundene for at protokollen skal være enkel, er at der ikke sendes meget data, dataene er enkel, og afstanden, den sendes, er kort. 
%Microwire er ikke full duplex. Så det er enten SSFt eller Freescale, der skulle bruges. Da SSFT havde færre opsætningsmuligheder, blev den valgt som protokol. 
%I SSFT ligger svaret på nogle af overvejelserne. Overvejelserne har været om MOSI skal trigger på rising eller falling edge, og hvordan Slave Select skulle opføre sig.
Microwire blev udelukket da den ikke er full-duplex og dermed ikke en SPI standard. 
Freescale formatet blev udelukket da opsætningen af denne vurderedes mere kompliceret end for SSFT,
uden at tilføje ekstra muligheder.
Valget faldt derfor på SSFT.

Størrelse af data framen blev valgt til 16 bit, hvilket giver mulighed for at sende
motorens PWM-duty cycle og deres position (begge 11 bit) samt kontroldata.
Opbygningen af de to datawords kan ses på figur \ref{fig:protokol1}.

\begin{figure}[h!]
\centering
\subfloat[Kommando fra mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPImasterslave}
\end{tikzpicture}
}
\qquad
\subfloat[Svar fra FPGA til mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
\label{fig:spi_from_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPIslavemaster}
\end{tikzpicture}
}
\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
\label{fig:protokol1}
\end{figure}
%\todo[inline, author=Michael]{flot figur, i like :)}

%\begin{figure}[h!]
%\centering
%\subfloat[Mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
%\begin{tabular}{|p{4cm}|}   \hline
 %   Motor (1 bit) \\   \hline
 %   Retning (1 bit) \\   \hline
%    Ignore PWM (1 bit) \\    \hline
%    N/A (2 bit) \\
 %    \\\hline
 %    \\ \\ \\ \\
 %   PWM duty cycle \\
 %   (11 bits) \\ \\ \\ \\ \\   \hline
%  \end{tabular}}
%\qquad
%\subfloat[FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
%\label{fig:spi_from_fpga}]{%
%\begin{tabular}{|p{4cm}|} \hline
  %  Motor (1 bit) \\    \hline \\
%    N/A (4 bit) \\
%     \\ \\    \hline
%     \\ \\ \\ \\
%    Position (ticks) \\
%    (11 bits) \\ \\ \\ \\ \\    \hline
%  \end{tabular}}
%\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
%\label{fig:protokol1}
%\end{figure}
Figur \ref{fig:spi_to_fpga} viser indholdet af datawords der bliver sendt fra mikrocontrolleren. 
Motorbit vælger aktuel motor, retningsbit vælger hvilken retning
denne skal dreje og PWM-duty cycle indeholder den ønskede PWM-duty cycle. 
Hvis setPWM bit ikke er sat ignoreres den modtagne besked,
mens den aktuelle motorposition stadig returneres som vist på figur \ref{fig:spi_from_fpga}. 

%Da SPI er full duplex sendes data fra  Mikrocontrolleren og FPGA’en synkront - FPGA’en sender et dataword samtidig med mikrocontrolleren
 %Mikrocontrolleren sender den  PWM, der skal sættes på den bestemte motor i den bestemte retning. Det er det motor- og retningsbittene bestemmer.
%På Mikrocontrolleren ville man gerne kunne få en position uden, at den sætter en ny PWM. 
%Derfor skal der bruges en bit, hvor FGPA’en kan se om den skal sætte PWM’en, eller om den kun skal sende information tilbage. Der er det PWMset bruges til.
%På figur \ref{fig:spi_from_fpga} ses dataword'et som FPGA'en sender. FPGA'en sender positionen på den bestemte motor. 

\subsection{Test} 
% Test af SPI overførsel
% Test af realtidsafvikling af reguleringssløjferne, 
% lever vi op til kravene?
%
%Deadband er testet ved at øge PWM med 6 [Hz] til en motor hvor der blev målt position med 600 [Hz].
%Ved at se hvornår der sker den første bevægelse er er målt at deadband målt til 141 for tilt og 221 for pan motoren.
%Dette er indsat i en langsom regulator som bliver brugt til at sætte en enkelt position. Her kan error signalet være %størst og der er ikke de samme tidskrav til systemet. 
%
%Den matematiske model er sammenlignet med plotdata fra open loop sløjfen på tilt systemet.
%Pan systemet kan ikke bevæge sig hele vejen rundt, så der er ikke foretaget en open loop test af denne motor.
%Testen består i at gå fra 0 til 2047 PWM i trin af 1. PWM bliver forøget med 60[Hz] og der bliver målt position med 600[Hz].
%Sammenligningen er plottet i appendix XXX og den største fejlmargen var XXX.
%
%
%Realtidsafviklingen af systemet er målt ved at sætte en pin på mikrocontroller boardet og måle resultatet med et oscilloscop.
%Afviklingen af en enkelt control loop i tracking stadiet er målt til XXX \(\micro\) sekunder
%Det kan også aflæses at der er en fast afstand på 1666.667 \(\micro\) sekunder fra start til start, så freeRTOS kan godt følge med til at skedulere med 600 [Hz].
%I appendix XXX kan der ses en måling hvor der både bliver målt længden af en task og SPI kommunikationen.
%
%
SPI funktionens afviklingstid blev testet ved at skifte en digital pin før og efter SPI-funktion blev kaldt.
Et oscilloskop af typen \textit{Agilent DSO-X 2024A} blev brugt til målingerne. 

SPI funktionens afviklingstid blev på oscilloskopet målt til 40,54 [\micro s].
I løbet af 10 parabelbevægelser blev observeret en afvigelse på \(\pm2\) [ns], hvilket svarer til måleusikkerheden. 
Altså overholder implementeringen kravet på afvikling indenfor 83,3 [\micro s], som opstillet i ligning \ref{eq:uc:spi-krav}.

%\begin{table}[h!]
%\centering
%%\begin{tabular}{|c|c|c|c|}\hline 
%%Max:  & Min: & Median: & Gennemsnit: \\\hline 
%%41,12 [\micro s] & 40,16 \micro s & 40,56 \micro s & 40,59 \micro s \\\hline 
%%\end{tabular} 
%\begin{tabu}{c|c|c|c}%{c|[1.25pt]c|c|c}
%Max:  & Min: & Median: & Gennemsnit: \\\hline % \tabucline[1.25pt]{-}
%41,12 [\micro s] & 40,16 \micro s & 40,56 \micro s & 40,59 \micro s 
%\end{tabu} 
%\caption{Data fra tests af SPI.}
%\label{tb:spi-tests}
%\end{table}

Samme fremgangsmåde blev brugt til at undersøge timingen for Control-task'en,
som indeholder reguleringssløjferne. Oscilloskopet blev indstillet til \(500.000\) [samples/s].
Kravet til afviklingen var: Reguleringsløjferne kører med 600 [Hz], samt at task'en afvikles inden næste periode. 
Dvs. en maks afviklingstid på \(\frac{1}{600}\) [s], da kravet på 600 [Hz] ellers ikke kunne opfyldes. 
Intervallet mellem hver afvikling af task'en blev målt for 60 afviklinger,
og resultaterne er vist i tabel \ref{tb:ctrltasktimingtest}.
\begin{table}[h!]
% Prøv multicolummn
\centering
\begin{tabu}{l|[1.25pt]r|r|r|r}
 & Max:  & Min: & Median: & Gennemsnit:  \\ \tabucline[1.25pt]{-}
Målt interval: & 1,672 [ms] & 1,662 [ms] & 1,667 [ms] & 1,667 [ms] \\ 
\hline 
Afvigelse: & 5,33 [\micro s] & 4,66 [\micro s] & 0,66 [\micro s] & 0,13 [\micro s] \\
\end{tabu} 
\caption[Interval mellem afvikling af Control task]{Interval mellem hver afvikling af Control-task. Måleusikkerheden er $\pm4$ [\micro s].}
\label{tb:ctrltasktimingtest}
\end{table}
%\todo[inline,author=Nikolaj, color=green]{Din afvigelse siger at du mangler et decimal...}

Afvigelserne for medianen og gennemsnittet ligger indenfor måleusikkerheden på $\pm4$  [\micro s].
For max. og min. værdierne er afvigelsen på max. 133\% af måleusikkerheden,
og det vurderes at denne kan negligeres. 

Samme datasæt blev brugt til at beregne afviklingstiden for task'en, koordinattransformationen og selve reguleringssløjfen. 
Disse data er vist i tabel \ref{tb:ctrl task runtime test}. %Bemærk usikkerheden på $4  [\micro s]$.

%500KSa/s
\begin{table}[h!]
\centering
\begin{tabu}{l|[1.25pt]r|r|r|r}
Afviklingstid & Max  &  Min & Median & Gennemsnit  \\ \tabucline[1.25pt]{-}
Ctrl task & 360 [\micro s] & 326 [\micro s] & 332 [\micro s] & 338 [\micro s] \\ \hline 
Koordinat transformation & 228 [\micro s] & 202 [\micro s] & 206 [\micro s] & 212 [\micro s] \\
\hline 
PID-regulering & 40 [\micro s] & 30 [\micro s] & 32 [\micro s] & 34 [\micro s]\\
\end{tabu} 
\captionsetup{width=0.8\textwidth}
\caption[Afviklingstiden for Control task]{Afviklingstiden for Control task, Koordinattransformation og PID-regulering. Måleusikkerheden er $\pm4$ [\micro s].}
\label{tb:ctrl task runtime test}
\end{table}

Dataene viser at Control task'en blev afviklet før sin deadline - med en margin på min. 1,294 [ms].
%\todo[inline,author=Nikolaj, color=green]{Skal man ikke tænke mindste målte interval - måleusikkerheden - længste afviklingstid? - Indregn worst case}
Variationen i afviklingstiden skyldes koordinattransformationen og PID-reguleringen. Den maksimale variation af afviklingstiden udgør $ \frac{360 - 326}{1667} = 2,04\% $ af periodetiden, hvilket kan tolereres. 

\subsection{Delkonklusion}
Det blev valgt at benytte den udleverede LM3S6965 mikrocontroller.
Denne understøtter SPI og UART som hardwaremoduler. 

Det blev valgt at bruge FreeRTOS til scheduleringen,
da tvungen schedulering med prioritet sikrer hård realtid. 

Programmet blev delt op i fem task's; UART send, UART receive, Interface, Logger og Control. 
% Al realtidsfunktionalitet blev implementeret i Control-task'en. 

Det var påkrævet at Control-task'en kunne afvikles med en frekvens på 600 [Hz]. 
Task'ens afviklingstid blev målt til max. 360 [\(\micro\)s], hvilket var væsentlig lavere end den max. tilladte tid på \(\frac{1}{600}\) [s]. 
SPI-kommunikationen kunne afvikles på 40,54 [\(\micro\)s], hvilket opfyldte kravet på max. 5\% af Control-task'ens periodetid. 

%Reguleringssløjferne kan ramme inden for kravene i kravspecifikationen.
