\section{Mikrocontroller}
\label{sec:mikrocontroller}
%
\subsection{Krav til mikrocontrolleren}
%\todo[inline, author=Michael]{Husk at TEST sektionen skal se om vi opfylder disse krav. Hvis ikke vi tester tingene skal de slettes fra dette afsnit!!!}
Mikrocontrolleren har følgende opgaver: 
%\todo[inline, author=Michael]{YOU CANT TOUCH THIS - lad mig lige skrive færdig!}
%\todo[inline, author=Michael]{Denne sektion mangler generelt at blive forkortet. }
%\todo[inline, author=Michael]{Anders, kan vi ændre layouttet så listerne ikke tager så meget plads? }

\begin{itemize}
\itemsep1pt
	\item Afvikling af regulatorerne.
	\item Kommunikation med FPGA vha. SPI.
	\item Modtage kommandoer fra PC'en via UART.
	\item Sende relevant data til brugeren via UART.
\end{itemize}

Regulatorerne skal afvikles i hård realtid\footnote{Dvs. at task'en skal afvikles, inden dens deadline - inden for en samplingperiode.},
da det ellers er vanskelligt at modellere de digitale regulatorer matematisk.

SPI\footnote{Serial Peripheral Interface, også kaldet SSI.} bruges til at overføre PTS's position fra FPGA til mikrocontroller.
Desuden overføres beregnet duty cycle fra mikrocontroller til FPGA.
Kommunikationen skal være tilpas hurtig, så regulatorerne ikke regner på forældet data.
Forsinkelsen for overførsel af data for begge motorer vurderes til ikke at måtte overstige 5\% af samplingperioden.
Ved $T_s = \frac{1}{600}$ er det: 
\begin{equation}
	T_{\text{SPI delay}} = \frac{1}{600} \cdot 5 \% = 8,33 \cdot 10^{-5}[s]
	\label{eq:uc:spi-krav}
\end{equation}

Systemet skal kunne modtage brugerinput gennem et terminalprogram.
Brugerinterfacet er ikke tidskritisk.
Der skal være mulighed for at udlæse væsentlige systemparametre såsom:
PTS' position, ønsket position, aktuel PWM duty cycle osv.
\todo[inline, author=Michael]{Måske skal disse systemparametre defineres mere fast.}
%\begin{itemize}
%\itemsep1pt
%	\item PTS' position. 
%	\item Ønsket position. 
%	\item Afvigelse fra ønsket position. 
%\end{itemize}
Desuden skal systemet gemme disse informationer i en log-fil,
som kan udlæses efter systemet er færdig med at tracke målet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Beskrivelse af mikrocontroller}
Den udleverede mikrocontroller er en 32 bit Stellaris LM3S6965, baseret på en ARM Cortex M3 kerne. Den opererer ved 50 [MHz] og bruger Thump 2 instruktionssættet. Den indeholder 256 [kB] flash hukommelse samt 64 [kB] SRAM \citep{lm3s6965}.

SPI er indbygget som et hardwaremodul, med seperate FIFO-buffere til afsendelse og modtagelse. Hardwaren sender data fra den ene den buffer og lægger modtaget data i den anden. Derfor er det ikke nødvendigt for programmøren at holde styr på timingen. Størrelsen af hvert dataframe kan være 4 - 16 bits. 

UART er også implementeret som et hardwaremodul. Modulet indeholder seperate FIFO-buffere til afsendelse og modtagelse af data, hver med plads til 16 datawords (på max. 8 bit). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Valg af scheduling/operativsystem}
Der er undersøgt fire forskellige muligheder for scheduling.
CooCox CoOS\footnote{\citep{www.coocox.com/CoOS.htm}} og FreeRTOS\footnote{\citep{freertos.org}}
er komplette realtids-operativsystemer. 
Run-To-Complete-Scheduler (RTCS) er en simpel scheduler med frivillig (non-preemtive) skedulering.
Ved Super loop metoden afvikles al koden i main-loopet vha. ticks.
De fire schedulings er beskrevet i tabel \ref{tb:os_comparison}.
%\begin{itemize}
%\itemsep-1pt
%	\item Opfylder kravene til realtidsafvikling af regulatorerne. 
%	\item Muligheden for at (gen)bruge elementer fra EMP-kurset.
%\end{itemize}

Til valget er der lagt vægt på om scheduleringen opfylder kravet til realtidsafvikling af regulatorerne, samt muligheden for at genanvende elementer fra programmeringskurset (EMP-kurset).
\begin{figure}[th!]
\centering

\begin{tabu}{l|[1.25pt]l|l|l|l}
 & CoOS & FreeRTOS & RTCS & Super loop \\ \tabucline[1.25pt]{-}
Scheduling & Preemptive priority  & Preemptive priority  & Non- & Non-  \\ 
	           & /round robin		& /round robin              &preemptive &preemptive	\\\hline 
Køer & Ja & Ja & Nej & Nej \\ \hline 
Semaforer & Tællende og Binære  & Tællende og Binære & Binære  & Nej  \\\hline 
Introduceret & Nej & Ja & Ja & Ja \\ 
i EMP &   &   &   &   \\
\end{tabu}
%\begin{tabu}{l|[1.25pt]l|l|l|l}
 %& CoOS & FreeRTOS & RTCS & Super loop \\ \tabucline[1.25pt]{-}
%Skedulering & Preemptive priority  & Preemptive priority  & Non-preemptive & Non-preemptive  \\ 
%	           & /round robin		& /round robin              & &	\\\hline 
%Køer & Ja & Ja & Nej & Nej \\ \hline 
%Semaforer & Tællende og Binære  & Tællende og Binære & Binære  & Nej  \\\hline 
%Introduceret & Nej & Ja & Ja & Ja \\ 
%i programmeringskurset &   &   &   &   \\
%\end{tabu}
%\begin{tabu}{|l|[1.25pt]l|l|l|l|}\hline
% & coOS & freeRTOS & RTCS & Super loop \\ \tabucline[1.25pt]{-}
%Skedulering & Preemptive priority  & Preemptive priority  & Non-preemptive & Non-preemptive  \\ 
%	           & /round robin		& /round robin              & &	\\\hline 
%Queues & Ja & Ja & Nej & Nej \\ \hline 
%Semaphore & Counting og Binære  & Counting og Binære & Binære  & Nej  \\\hline 
%Introduceret & Nej & Ja & Ja & Ja \\ 
%i EMP kurset &   &   &   &   \\\hline
%\end{tabu}
\captionsetup{type=table}
\caption{Specifikationer for de undersøgte systemer}
\label{tb:os_comparison}
\end{figure}

Med kravet om hård realtid og for at lette programmeringsarbejdet valgtes det at
benytte FreeRTOS, fordi det tilbyder tvungen scheduling (preemptive priority), hvor det er muligt
at prioritere regulerings-task'en højere end resten af programmet.

%
\subsection{Implementering}
%disp: 
% task diagram
% beskrivelse af tasks
% implementering af enkelt task (CONTROL TASK). 
%   - hvordan sikres at denne kører realtid.
% 
% beskrivelse af interfacet
% 
%\todo[inline, author=Michael]{Venter på at kodens struktur er helt færdig - inden da giver det ikke mening at skrive dette afsnit færdigt. }
Systemet er opdelt i separate tasks.
Taskdiagrammet er vist på figur \ref{fig:task_diagram}. 

% TASK DIAGRAM
\begin{figure}[!h]
\centering
\begin{tikzpicture}[node distance = 3.2cm]
	\include*{./graphics/uc_task_diagram}
\end{tikzpicture}
\caption[Taskdiagram]{Taskdiagrammet viser programmets opdeling i tasks.}
\label{fig:task_diagram}
\end{figure}

\subsubsection{Beskrivelse af de enkelte tasks}
\begin{description}
\itemsep-3pt
	\item[UART send og -receive] Fordi UART hw.-bufferen kun indeholder 16 pladser \citep[s. 430]{lm3s6965}
	sørger en Send og en Recieve task for at sende data videre til og fra resten af programmet.
	De to ekstra semaforer, som Interface tilgår er til at reservere de to buffers så indtastede og
	printede tekststrenge ikke kan afbrydes (kun én task kan skrive til eller læse fra UART ad gangen).
	\item[Control] Afvikler regulatorerne. Se mere indgående beskrivelse i sektion \ref{sec:control_task}.
	Denne task afvikles i realtid, med en frekvens på 600 [Hz]. 
	Denne task sørger for at SPI Kommunikationen med FPGA'en bliver afviklet på de rigtige tidspunkter.
	\item[Logger] Denne task opdaterer logfilen med data fra "status"-køen.
	\item[Interface] Tolker på brugerinputs og sender relevante kommandoer til Control task'en.
\end{description}

\subsubsection{Control task}
\label{sec:control_task}
Control task'en henter en koordinat, transformerer koordinaten,
udregner en PWM duty cycle for hver regulator og opdaterer loggen.
Hver gang control task'en bliver kørt bliver der hentet to positioner
ind via SPI mens de to nye PWM duty cycles sendes.
Control tasken ved hvilke ting der er relevant at gemme i loggen,
så ved start af tracking bliver positioner og PWM duty cycles gemt i loggen.
I kodeudsnittet \ref{ctrl_task} ses task'en som den bliver kørt hvis den er i tracking stadiet.
\todo[inline,author=Mikael]{Fix henvisning til kodeudsnit, som for resten ikke bør hedde Listing.}
\lstinputlisting[language=c, 
        firstnumber=120,
        firstline=120, 
        lastline=122,
        ]{codeexample/ctrl_task.c}
\(\vdots\)
\lstinputlisting[language=c, 
        firstnumber=155,
        firstline=155, 
        lastline=163,
        ]{codeexample/ctrl_task.c}
\(\vdots\)
\lstinputlisting[language=c, 
        firstnumber=180,
        firstline=180, 
        lastline=186,
        caption={ af ctrl\_task.c.\label{ctrl_task}}
        ]{codeexample/ctrl_task.c}

\subsubsection{Interface task}
\label{sec:interface}
Brugerinterfacet gør det overskueligt at styre og skifte mellem de forskellige tilstande som systemet kan køres i.
Der er lavet funktioner som bruges til test af specifikke funktioner (fx at sætte en bestemt PWM duty cycle)
og funktioner som starter en større test (fx tracking af lerdueparablen).
Formålet er at simplificere arbjedet med udviklingen og justeringen af regulatoren -
det er altså ikke tænkt til en kunde som ikke ved noget om systemet.
De primære funktioner er at sætte en position eller starte tracking af lerduen.
Hvis det indtastede ikke bliver genkendt bliver en liste over gyldige funktioner udskrevet.

\begin{figure}[th!]
\centering
\begin{tabu}{l|[1.25pt]l|l}
Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
start & Start tracking af lerdue &   \\\hline 
stop & Stop systemet &   \\\hline 
open & Start åben sløjfe test &  \\\hline  
reset & Gå til udgangsposition &   \\\hline 
C fxx.fyy.fzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter, \\         
            & &  f = fortegn ($+$ ell. $-$)\\\hline 
A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
& & f = fortegn ($+$ ell. $-$),  \\
& & xx = PWM dutycycle i \%
\end{tabu} 

%\begin{tabu}{|l|[1.25pt]l|l|}\hline
%Kommando: & Funktion: & Parametre: \\\tabucline[1.25pt]{-}
%read & Slå log til eller fra.  &   \\\hline 
%start & Start tracking af lerdue &   \\\hline 
%stop & Stop systemet &   \\\hline 
%open & Start åben sløjfe test &  \\\hline  
%reset & Gå til udgangsposition &   \\\hline 
%C xxx.yyy.zzz & Gå til  kartesisk koord. (x,y,z) & x,y,z = Koordinaterne i meter \\\hline 
%A aaaa.bbbb & Gå til sfærisk koord.  & a = Tilt, b = Pan, begge i ticks. \\\hline  
%Pmfxx & Sæt dutycycle for motor m & m = Motor ("A" ell. "B"), \\ 
%& & f = fortegn ($+$ ell. $-$),  \\
%& & xx = PWM dutycycle i \%\\\hline
%\end{tabu} 
\captionsetup{type=table}
\caption{Brugerinterfacets kommandoer.}
\label{tb:uart_interface}
\end{figure}

\subsubsection{SPI}
\label{sec:spi-implementering}
Det blev vedtaget at mikrocontrolleren var masteren og FPGA'en blev slaven, da FPGA'en helst skulle være så enkel som mulig.

Mikrocontrollerens SPI-modul har indbygget tre forskellige standarder: TI Synchronous Serial Frame Format (SSFT), Freescale og Microwire. 
%Til at overfører data mellem Mikrocontrolleren og FPGA’en skal der bruges en enkel protokol med full duplex. \todo[author=Anders]{Hovedgrundene til valget af SPI protokol.}
%Hovedgrundene for at protokollen skal være enkel, er at der ikke sendes meget data, dataene er enkel, og afstanden, den sendes, er kort. 
%Microwire er ikke full duplex. Så det er enten SSFt eller Freescale, der skulle bruges. Da SSFT havde færre opsætningsmuligheder, blev den valgt som protokol. 
%I SSFT ligger svaret på nogle af overvejelserne. Overvejelserne har været om MOSI skal trigger på rising eller falling edge, og hvordan Slave Select skulle opføre sig.
Microwire blev udelukket da den ikke er full-duplex og dermed ikke en SPI standard. 
Freescale formatet blev udelukket da opsætningen af denne vurderedes mere kompliceret end for SSFT,
uden at tilføje ekstra muligheder.
Valget faldt derfor på SSFT.

Størrelse af data framen blev valgt til 16 bit, hvilket giver mulighed for at sende
motorens PWM-duty cycle og deres position (begge 11 bit) samt kontroldata.
Opbygningen af de to datawords kan ses på figur \ref{fig:protokol1}.

\begin{figure}[h!]
\centering
\subfloat[Kommando fra mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPImasterslave}
\end{tikzpicture}
}
\qquad
\subfloat[Svar fra FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
\label{fig:spi_from_fpga}]{%
\begin{tikzpicture}[scale=1]
\include*{./graphics/SPIslavemaster}
\end{tikzpicture}
}
\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
\label{fig:protokol1}
\end{figure}
%\todo[inline, author=Michael]{flot figur, i like :)}

%\begin{figure}[h!]
%\centering
%\subfloat[Mikrocontroller til FPGA.\label{fig:spi_to_fpga}]{%
%\begin{tabular}{|p{4cm}|}   \hline
 %   Motor (1 bit) \\   \hline
 %   Retning (1 bit) \\   \hline
%    Ignore PWM (1 bit) \\    \hline
%    N/A (2 bit) \\
 %    \\\hline
 %    \\ \\ \\ \\
 %   PWM duty cycle \\
 %   (11 bits) \\ \\ \\ \\ \\   \hline
%  \end{tabular}}
%\qquad
%\subfloat[FPGA til Mikrocontroller. Der skiftes mellem at sende position for pan og tilt hver gang.
%\label{fig:spi_from_fpga}]{%
%\begin{tabular}{|p{4cm}|} \hline
  %  Motor (1 bit) \\    \hline \\
%    N/A (4 bit) \\
%     \\ \\    \hline
%     \\ \\ \\ \\
%    Position (ticks) \\
%    (11 bits) \\ \\ \\ \\ \\    \hline
%  \end{tabular}}
%\caption[Indholdet af SPI datawords]{Viser indholdet af SPI datawords. }
%\label{fig:protokol1}
%\end{figure}
Figur \ref{fig:spi_to_fpga} viser indholdet af datawords der bliver sendt fra Mikrocontrolleren. 
Motorbitten vælger aktuel motor, retningsbitten vælger hvilken retning
denne skal dreje og PWM-duty cycle indeholder den ønskede PWM. 
Hvis Ignore-bitten er sat ignoreres den modtagne besked,
mens den aktuelle motorposition stadig returneres som vist på figur \ref{fig:spi_from_fpga}. 
%Da SPI er full duplex sendes data fra  Mikrocontrolleren og FPGA’en synkront - FPGA’en sender et dataword samtidig med mikrocontrolleren
 %Mikrocontrolleren sender den  PWM, der skal sættes på den bestemte motor i den bestemte retning. Det er det motor- og retningsbittene bestemmer.
%På Mikrocontrolleren ville man gerne kunne få en position uden, at den sætter en ny PWM. 
%Derfor skal der bruges en bit, hvor FGPA’en kan se om den skal sætte PWM’en, eller om den kun skal sende information tilbage. Der er det PWMset bruges til.
%På figur \ref{fig:spi_from_fpga} ses dataword'et som FPGA'en sender. FPGA'en sender positionen på den bestemte motor. 

\subsection{Test} 
% Test af SPI overførsel
% Test af realtidsafvikling af reguleringssløjferne, 
% lever vi op til kravene?
%
%Deadband er testet ved at øge PWM med 6 [Hz] til en motor hvor der blev målt position med 600 [Hz].
%Ved at se hvornår der sker den første bevægelse er er målt at deadband målt til 141 for tilt og 221 for pan motoren.
%Dette er indsat i en langsom regulator som bliver brugt til at sætte en enkelt position. Her kan error signalet være %størst og der er ikke de samme tidskrav til systemet. 
%
%Den matematiske model er sammenlignet med plotdata fra open loop sløjfen på tilt systemet.
%Pan systemet kan ikke bevæge sig hele vejen rundt, så der er ikke foretaget en open loop test af denne motor.
%Testen består i at gå fra 0 til 2047 PWM i trin af 1. PWM bliver forøget med 60[Hz] og der bliver målt position med 600[Hz].
%Sammenligningen er plottet i appendix XXX og den største fejlmargen var XXX.
%
%
%Realtidsafviklingen af systemet er målt ved at sætte en pin på mikrocontroller boardet og måle resultatet med et oscilloscop.
%Afviklingen af en enkelt control loop i tracking stadiet er målt til XXX \(\micro\) sekunder
%Det kan også aflæses at der er en fast afstand på 1666.667 \(\micro\) sekunder fra start til start, så freeRTOS kan godt følge med til at skedulere med 600 [Hz].
%I appendix XXX kan der ses en måling hvor der både bliver målt længden af en task og SPI kommunikationen.
%
%
SPI blev testet ved at skifte en digital pin før og efter SPI-funktion blev kaldt.
Et oscilloskop af typen \textit{Agilent DSO-X 2024A} blev brugt til målingerne. 

SPI funktionens afviklingstid blev på scopet målt til 40,54 [ \micro s].
I løbet af 10 parabelbevægelser blev observeret en afvigelse på $\pm 2 [ ns]$, hvilket svarer til måleusikkerheden. 
Altså overholder implementeringen kravet på afvikling indenfor 83,3 [\micro s], som opstillet i ligning \ref{eq:uc:spi-krav}.

%\begin{table}[h!]
%\centering
%%\begin{tabular}{|c|c|c|c|}\hline 
%%Max:  & Min: & Median: & Gennemsnit: \\\hline 
%%41,12 [\micro s] & 40,16 \micro s & 40,56 \micro s & 40,59 \micro s \\\hline 
%%\end{tabular} 
%\begin{tabu}{c|c|c|c}%{c|[1.25pt]c|c|c}
%Max:  & Min: & Median: & Gennemsnit: \\\hline % \tabucline[1.25pt]{-}
%41,12 [\micro s] & 40,16 \micro s & 40,56 \micro s & 40,59 \micro s 
%\end{tabu} 
%\caption{Data fra tests af SPI.}
%\label{tb:spi-tests}
%\end{table}

Samme fremgangsmåde blev brugt til at undersøge timingen for Control-task'en,
som indeholder reguleringssløjferne. Oscilloskopet blev indstillet til \(500.000\) Samples/s.
Kravet til afviklingen var: Reguleringsløjferne kører med 600 [Hz], samt at task'en afvikles inden næste periode. 
Dvs. en maks afviklingstid på \(\frac{1}{600}\) [s], da kravet på 600 [Hz] ellers ikke kunne opfyldes. 
Intervallet mellem hver afvikling af task'en blev målt for 60 afviklinger,
og resultaterne er vist i tabel \ref{tb:ctrltasktimingtest}.
\begin{table}[h!]
\centering
\begin{tabu}{l|[1.25pt]r|r|r|r}
 & Max:  & Min: & Median: & Gennemsnit:  \\ \tabucline[1.25pt]{-}
Målt interval: & 1,672 [ms] & 1,662 [ms] & 1,667 [ms] & 1,667 [ms] \\ 
\hline 
Afvigelse: & 5,33 [\micro s] & 4,66 [\micro s] & 0,66 [\micro s] & 0,13 [\micro s] \\
\end{tabu} 
\caption{Interval mellem hver afvikling af Control-task.}
\label{tb:ctrltasktimingtest}
\end{table}
\todo[inline,author=Nikolaj, color=green]{Din afvigelse siger at du mangler et decimal...}

Afvigelserne for medianen og gennemsnittet ligger indenfor måleusikkerheden på $\pm 4  [\micro s] $.
For max. og min. værdierne er afvigelsen på max 133 \% af måleusikkerheden,
og det vurderes at disse kan negligeres. 

Samme datasæt blev brugt til at beregne afviklingstiden for tasken, koordinattransformationen og selve reguleringssløjfen. 
Disse data er vist i tabel \ref{tb:ctrl task runtime test}. %Bemærk usikkerheden på $4  [\micro s]$.

%500KSa/s
\begin{table}[h!]
\centering
\begin{tabu}{l|[1.25pt]r|r|r|r}
Afviklingstid & Max:  &  Min: & Median: & Gennemsnit:  \\ \tabucline[1.25pt]{-}
Ctrl task: & 360 [\micro s] & 326 [\micro s] & 332 [\micro s] & 338 [\micro s] \\ \hline 
Koordinat transformation: & 228 [\micro s] & 202 [\micro s] & 206 [\micro s] & 212 [\micro s] \\
\hline 
PID kontroller: & 40 [\micro s] & 30 [\micro s] & 32 [\micro s] & 34 [\micro s]\\
\end{tabu} 
\caption{Afviklingstiden for Control task, Koordinattransformation og PID-regulatoren.\\
Måleusikkerheden er $\pm$ 4 [\micro s].}
\label{tb:ctrl task runtime test}
\end{table}

På trods af at afviklingstiden varierer, afvikles tasken før sin deadline - med en margin på min. 1,298 [ms] til næste task. 
\todo[inline,author=Nikolaj, color=green]{Skal man ikke tænke mindste målte interval - måleusikkerheden - længste afviklingstid?}
Variationen i afviklingstiden skyldes primært koordinattransformationen, der benytter \textbf{math.h} librariet. 

\todo[inline, author=Michael]{Skal vi bruge plads på at teste interfacet også? }
\todo[inline,author=Nikolaj, color=green]{text goes in, text comes out. You can't explain that}
\subsection{Delkonklusion}
Det blev valgt at benytte den udleverede LM3S6965 microcontroller. Denne understøtter SPI og UART som hardware moduler. 

Til scheduleringen blev valgt operativsystemet freeRTOS, da det blev vurderet at preemptive priority var tilstrækkeligt til at møde vores realtidskrav. 

Programmet blev delt op i 5 tasks; \textit{UART send}, \textit{UART receive}, \textit{Interface}, \textit{Logger} og \textit{Control}. 
Al realtidsfunktionalitet er implementeret i \textit{Control}-tasken. 

Det var påkrævet at \textit{Control}-tasken kunne afvikles med en frekvens på $600 [Hz]$. 
Taskens afviklingstid blev målt til max. $360 [\micro s]$, hvilket er væsentlig lavere end den max. tilladte tid på $\frac{1}{600}  [s]$. 
SPI-kommunikationen kunne afvikles på 40,54 [ \micro s], hvilket opfyldt kravet på max. 5\% af \textit{Control}-taskens periodetid. 



%Reguleringssløjferne kan ramme inden for kravene i kravspecifikationen.
